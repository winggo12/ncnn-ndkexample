package com.cheungbh.yogasdk.view

import android.Manifest
import android.app.Activity
import android.app.AlertDialog
import android.app.Dialog
import android.content.Context
import android.content.ContextWrapper
import android.content.pm.PackageManager
import android.graphics.ImageFormat
import android.hardware.camera2.*
import android.hardware.camera2.params.StreamConfigurationMap
import android.media.Image
import android.media.ImageReader
import android.media.ImageReader.OnImageAvailableListener
import android.os.Bundle
import android.os.Handler
import android.os.HandlerThread
import android.util.AttributeSet
import android.util.Log
import android.util.Size
import android.view.Surface
import android.view.SurfaceHolder
import android.view.SurfaceView
import android.view.View
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.fragment.app.DialogFragment
import java.util.concurrent.Semaphore
import java.util.concurrent.TimeUnit

class CameraView: SurfaceView {
    companion object {
        const val REQUEST_CAMERA_PERMISSION = 20
        private const val TAG = "CameraView"
        private const val subtag = "flow"
    }

    /** Permission events Listener */
    interface EventListener{
        fun onImageAvailable(image: Image)
        fun onCalculateDimension(width: Int, height: Int)
    }
    private var eventListener: EventListener? = null
    private var swappedDimensions: Boolean = false
    private var isSurfaceCreated: Boolean = false
    private var isSurfaceChanged: Boolean = false
    private var isPermissionGranted: Boolean = false

    private var sensorOrientation: Int? = null

    /** camera set up state
     * 0 = init
     * 1 = called CameraView.setUpCameraOutputs
     * 2 = called CameraDevice.StateCallback.onOpened
     * 3 = called CameraView.createCameraPreviewSession
     * */
    private var cameraSetUpState: Int = 0
    /** default camera facing */
    private var mCameraFacing = CameraCharacteristics.LENS_FACING_BACK
    /** max grantee preview resolution */
    private var maxPreviewWidth = 1920
    private var maxPreviewHeight = 1080

    /** parent layout size */
    private var maxSurViewWidth = -1
    private var maxSurViewHeight = -1

    /** selected surfaceview size */
    private  var surfaceViewSize: Size = Size(0, 0)

    /** selected preview resolution */
    private lateinit var previewSize: Size


    /** imageReader output resolution */
    private lateinit var imgReaderSize: Size

    /** ID of the current [CameraDevice].   */
    private var cameraId: String? = null

    /** A [CameraCaptureSession] for camera preview.   */
    private var captureSession: CameraCaptureSession? = null

    /** A reference to the opened [CameraDevice].    */
    private var cameraDevice: CameraDevice? = null

    /** An additional thread for running tasks that shouldn't block the UI.   */
    private var backgroundThread: HandlerThread? = null

    /** A [Handler] for running tasks in the background.    */
    private var backgroundHandler: Handler? = null

    /** An [ImageReader] that handles preview frame capture.   */
    private var imageReader: ImageReader? = null

    /** [CaptureRequest.Builder] for the camera preview   */
    private var previewRequestBuilder: CaptureRequest.Builder? = null

    /** [CaptureRequest] generated by [.previewRequestBuilder   */
    private var previewRequest: CaptureRequest? = null

    /** A [Semaphore] to prevent the app from exiting before closing the camera.    */
    private val cameraOpenCloseLock = Semaphore(1)

    /** Whether the current camera device supports Flash or not.    */
    private var flashSupported = false

    /** [CameraDevice.StateCallback] is called when [CameraDevice] changes its state.   */
    private val stateCallback = object : CameraDevice.StateCallback() {

        override fun onOpened(cameraDevice: CameraDevice) {
            cameraOpenCloseLock.release()
            this@CameraView.cameraDevice = cameraDevice
            Log.d(TAG, "stateCallback.onOpened")
            createCameraPreviewSession()
        }

        override fun onDisconnected(cameraDevice: CameraDevice) {
            cameraOpenCloseLock.release()
            cameraDevice.close()
            this@CameraView.cameraDevice = null
        }

        override fun onError(cameraDevice: CameraDevice, error: Int) {
            onDisconnected(cameraDevice)
            activity?.finish()
        }
    }

    /**
     * A [CameraCaptureSession.CaptureCallback] that handles events related to JPEG capture.
     */
    private val captureCallback = object : CameraCaptureSession.CaptureCallback() {
        override fun onCaptureProgressed(
            session: CameraCaptureSession,
            request: CaptureRequest,
            partialResult: CaptureResult
        ) {
        }

        override fun onCaptureCompleted(
            session: CameraCaptureSession,
            request: CaptureRequest,
            result: TotalCaptureResult
        ) {
        }
    }

    /** A [OnImageAvailableListener] to receive frames as they are available.  */
    private var imageAvailableListener = object : OnImageAvailableListener {
        override fun onImageAvailable(imageReader: ImageReader) {
            /** measure fps */
            val now = System.currentTimeMillis()
            val onImgAvaListCallPeriod = now - onImgAvaListLastCall
            onImgAvaListLastCall = now
            Log.d(tag,"onImgAvaListCallPeriod = $onImgAvaListCallPeriod ms")
            Log.d(tag, "Current thread = ${Thread.currentThread()}")

            try{
                /** read image from ImageReader */
                val image = imageReader.acquireLatestImage() ?: return
                //val imgPlanes = image.planes
                image.planes
                if(eventListener != null){
                    eventListener!!.onImageAvailable(image)
                }
                Log.d(tag, "image.width = ${image.width}, image.height = ${image.height}")
                image.close()
            }catch(e: IllegalStateException){
                Log.e(tag, e.stackTrace.toString())
            }


        }
    }
    private val surfaceHolderCallback = object: SurfaceHolder.Callback{
        /** [SurfaceHolder.Callback] */
        override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {
            Log.d(tag, "surfaceChanged")
            Log.d(tag, "width = $width, height = $height")
            Log.d(tag, "holder.surface = ${holder!!.surface}")
            if(width == previewSize.width && height == previewSize.height){
                isSurfaceChanged = true
                if(isPermissionGranted){
                    openCamera()
                }

            }
        }

        override fun surfaceDestroyed(holder: SurfaceHolder) {
            Log.d(tag, "surfaceDestroyed")
        }

        override fun surfaceCreated(holder: SurfaceHolder) {

            isSurfaceCreated = true
            setUpCameraOutputs()

        }

    }

    /** last call time of [imageAvailableListener]  */
    private var onImgAvaListLastCall: Long = 0
    private var activity: Activity? = null
    private val tag = "CameraView"
    /**************************************************************************************/
    constructor(context: Context):super(context)
    constructor(context: Context, attrs: AttributeSet): super(context, attrs)
    init{
        Log.d(TAG, "$subtag: init(): Current thread = ${Thread.currentThread()}")
        //setSecure(true)
        // Gross way of unwrapping the Activity so we can get the FragmentManager
        var actContext = context
        while (actContext is ContextWrapper) {
            if (actContext is Activity) {
                activity = actContext as Activity
            }
            Log.d(tag, "actContext is Activity = ${actContext is Activity}")
            actContext = (actContext as ContextWrapper).baseContext
        }

    }



    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        Log.d(TAG, "$subtag: CameraView.onMeasure")

        val width = MeasureSpec.getSize(widthMeasureSpec)
        val height = MeasureSpec.getSize(heightMeasureSpec)

        Log.d(tag, "MeasureSpec.getSize(heightMeasureSpec) = $height, MeasureSpec.getSize(widthMeasureSpec) = $width")
        val svWidth = surfaceViewSize.width
        val svHeight = surfaceViewSize.height
        Log.d(tag, "svHeight = $svHeight, svWidth = $svWidth")
        if (0 == svWidth || 0 == svHeight) {
            setMeasuredDimension(width, height)
        } else {
            setMeasuredDimension(svWidth, svHeight)
        }


    }

    fun onResume(){
        Log.d(TAG, "$subtag: CameraView.onResume")
        cameraSetUpState = 0
        startBackgroundThread()
        this.holder!!.addCallback(surfaceHolderCallback)
    }

    fun onPause() {
        Log.d(TAG, "$subtag: CameraView.onPause")

        closeCamera()
        stopBackgroundThread()
    }

    /**
     * set the camera used
     * */
    fun setCameraFacing(targetFacing: Int = CameraCharacteristics.LENS_FACING_BACK){
        Log.d(TAG, "$subtag: CameraView.setCameraFacing")

        mCameraFacing = targetFacing

        if(cameraSetUpState >= 1){
            setUpCameraOutputs()
            openCamera()
        }
    }

    /**
     * set listener for different events this UI receive
     * */
    fun setEventListener(eventListener: EventListener){
        Log.d(TAG, "$subtag: CameraView.setEventListener")

        this.eventListener = eventListener
    }


    /**
     * Shows a [Toast] on the UI thread.
     *
     * @param text The message to show
     */

    private fun showToast(text: String) {
        val activity = activity
        activity?.runOnUiThread { Toast.makeText(activity, text, Toast.LENGTH_SHORT).show() }
    }

    /*************************** Permission *********************************/


    fun permissionGranted(){
        Log.d(TAG, "$subtag: CameraView.permissionGranted")

        isPermissionGranted = true
        if(isSurfaceChanged){
            openCamera()
        }
    }
    fun permissionDenied(){
        Log.d(TAG, "$subtag: CameraView.permissionDenied")

        isPermissionGranted = false
    }
    /*****************************************************************************/

    /**
     * Opens the camera specified by [TestPosenetFragment.cameraId].
     * Try to open camera and register a callback when camera is opened
     */
    private fun openCamera() {
        Log.d(TAG, "$subtag: CameraView.openCamera")

        val permissionCamera = ContextCompat.checkSelfPermission(activity!!, Manifest.permission.CAMERA)
        if (permissionCamera != PackageManager.PERMISSION_GRANTED)  return

        val cameraManager = activity!!.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        try {
            // Wait for camera to open - 2.5 seconds is sufficient
            if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw RuntimeException("Time out waiting to lock camera opening.")
            }

            cameraManager.openCamera(cameraId ?: "0", stateCallback, backgroundHandler)
        } catch (e: CameraAccessException) {
            Log.e(TAG, e.toString())
        } catch (e: InterruptedException) {
            throw RuntimeException("Interrupted while trying to lock camera opening.", e)
        }
    }

    /**
     * Closes the current [CameraDevice].
     */
    private fun closeCamera() {
        Log.d(TAG, "$subtag: CameraView.closeCamera")

        if (captureSession == null) {
            return
        }

        try {
            cameraOpenCloseLock.acquire()
            captureSession!!.close()
            captureSession = null
            cameraDevice!!.close()
            cameraDevice = null
            imageReader!!.close()
            imageReader = null
        } catch (e: InterruptedException) {
            throw RuntimeException("Interrupted while trying to lock camera closing.", e)
        } finally {
            cameraOpenCloseLock.release()
        }
    }

    /**
     * Starts a background thread and its [Handler].
     */
    private fun startBackgroundThread() {
        Log.d(TAG, "$subtag: CameraView.startBackgroundThread")

        backgroundThread = HandlerThread("imageAvailableListener").also { it.start() }
        backgroundHandler = Handler(backgroundThread!!.looper)
    }

    /**
     * Stops the background thread and its [Handler].
     */
    private fun stopBackgroundThread() {
        Log.d(TAG, "$subtag: CameraView.stopBackgroundThread")

        backgroundThread?.quitSafely()
        try {
            backgroundThread?.join()
            backgroundThread = null
            backgroundHandler = null
        } catch (e: InterruptedException) {
            Log.e(TAG, e.toString())
        }
    }

    /**
     * Sets up camera for preview and image capture, detriment the UI size, preview resolution and the resolution of
     * image captured.
     * UI will be resized in this function
     */
    private fun setUpCameraOutputs() {
        Log.d(TAG, "$subtag: CameraView.setUpCameraOutputs")
        try {
            val cameraManager
                    = activity!!.getSystemService(Context.CAMERA_SERVICE) as CameraManager

            cameraId = cameraManager.cameraIdList[0] // Default to back camera

            for (id in cameraManager.cameraIdList) {
                val characteristics: CameraCharacteristics =
                    cameraManager.getCameraCharacteristics(id)
                val cameraFacing: Int = characteristics.get(CameraCharacteristics.LENS_FACING) ?: mCameraFacing
                if (cameraFacing == mCameraFacing) {
                    cameraId = id
                    break
                }
            }
//            for (cameraId in manager.cameraIdList) {

                /** get camera characteristics */

                val characteristics = cameraManager.getCameraCharacteristics(cameraId ?: "0")

                //val cameraDirection = characteristics.get(CameraCharacteristics.LENS_FACING)

                val deviceOrientation =  activity!!.windowManager.defaultDisplay.rotation

                sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION)!!

                this.cameraId = cameraId

                // Check if the flash is supported.
                flashSupported =
                    characteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE) == true
                Log.d(tag, "displayRotation = ${deviceOrientation}, sensorOrientation = $sensorOrientation")
                val map: StreamConfigurationMap? =
                    characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)

                /** get the list of possible resolution of camera output */
                val resolFromCamera = map!!.getOutputSizes(ImageFormat.YUV_420_888)!!

                Log.d(tag, "List of camera output resolution:")
                for(resol in resolFromCamera){
                    Log.d(tag, "resol.width = ${resol.width}, resol.height = ${resol.height}")
                }

                /** get possible camera preview resolution for SurfaceView */
                Log.d(tag, "List of resolution supported by Surfaceview's surface:")
                val possibleSurfaceOutSizes = map.getOutputSizes(SurfaceHolder::class.java).toList()
                for(size in possibleSurfaceOutSizes){
                    Log.d(tag, "size.width = ${size.width}, size.height = ${size.height}")
                }

                /** get possible ImageReader output resolution */
                Log.d(tag, "List of resolution supported by Image's surface:")
                val imgReaderOutSizes = map.getOutputSizes(ImageReader::class.java).toList()
                for(size in imgReaderOutSizes){
                    Log.d(tag, "size.width = ${size.width}, size.height = ${size.height}")
                }

                /** get parent layout size */
                maxSurViewHeight = (this.parent as View).height
                maxSurViewWidth = (this.parent as View).width
                Log.d(tag, "maxSurfaceWidth = $maxSurViewWidth, maxSurfaceHeight = $maxSurViewHeight")

                /** correct dimension info according to sensor and device orientation */

                if(deviceOrientation == Surface.ROTATION_0 || deviceOrientation == Surface.ROTATION_180){
                    if (sensorOrientation == 90 || sensorOrientation == 270) {
                        swappedDimensions = true
                    }
                }else if(deviceOrientation == Surface.ROTATION_90 || deviceOrientation == Surface.ROTATION_270){
                    if (sensorOrientation == 0 || sensorOrientation == 180) {
                        swappedDimensions = true
                    }
                }else{
                    Log.e(TAG, "Display rotation is invalid: $deviceOrientation")
                }

                if(swappedDimensions){
                    val temp = maxSurViewHeight
                    maxSurViewHeight = maxSurViewWidth
                    maxSurViewWidth = temp

                }


                /** select a suitable size for surfaceview and preview resolution */
                val result = selectPreviewSizeResolution(possibleSurfaceOutSizes, deviceOrientation)
                surfaceViewSize = result[0]
                previewSize = result[1]
                Log.d(tag, "surfaceViewSize.width = ${surfaceViewSize.width}, surfaceViewSize.height = ${surfaceViewSize.height}")
                Log.d(tag, "previewSize.width = ${previewSize.width}, previewSize.height = ${previewSize.height}")

                /** select a suitable resolution for ImageReader  */
                imgReaderSize = selectImgReaderResolution(previewSize, possibleSurfaceOutSizes)
                Log.d(tag, "imgReaderSize.width = ${imgReaderSize.width}, imgReaderSize.height = ${imgReaderSize.height}")

                /** set surface size = set preview resolution */
                if(swappedDimensions){
                    surfaceViewSize = Size(surfaceViewSize.height, surfaceViewSize.width)
                }
                Log.d(tag, "setFixedSize")
                Log.d(tag, "Current thread = ${Thread.currentThread()}")
                this.holder.setFixedSize(previewSize.width, previewSize.height)
                imageReader = ImageReader.newInstance(
                    imgReaderSize.width, imgReaderSize.height, ImageFormat.YUV_420_888, 6
                )

                Log.d(tag, "requestLayout")
                if(eventListener != null){
                    eventListener!!.onCalculateDimension(surfaceViewSize.width, surfaceViewSize.height)
                }
                requestLayout()
                cameraSetUpState = 1
//                return
//            }
        } catch (e: CameraAccessException) {
            Log.e(TAG, e.toString())
        } catch (e: NullPointerException) {
            // Currently an NPE is thrown when the Camera2API is used but not supported on the
            // device this code runs.
            Log.e(TAG, "This device does not support Camera2 API.")

        }
    }

    /**
     * Creates a new [CameraCaptureSession] for camera preview, set up surfaces
     */
    private fun createCameraPreviewSession() {
        Log.d(TAG, "$subtag: CameraView.createCameraPreviewSession")

        try {
            imageReader!!.setOnImageAvailableListener(imageAvailableListener, backgroundHandler)

            // This is the surface we need to record images for processing.
            val listOfSurface = listOf<Surface>(holder!!.surface, imageReader!!.surface)

            // We set up a CaptureRequest.Builder with the output Surface.
            previewRequestBuilder = cameraDevice!!.createCaptureRequest(
                CameraDevice.TEMPLATE_PREVIEW
            )
            for(surface in listOfSurface) {
                previewRequestBuilder!!.addTarget(surface)
            }
            // Here, we create a CameraCaptureSession for camera preview.
            cameraDevice!!.createCaptureSession(
                listOfSurface,
                object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(cameraCaptureSession: CameraCaptureSession) {
                        // The camera is already closed
                        if (cameraDevice == null) return

                        // When the session is ready, we start displaying the preview.
                        captureSession = cameraCaptureSession
                        try {
                            // Auto focus should be continuous for camera preview.
                            previewRequestBuilder!!.set(
                                CaptureRequest.CONTROL_AF_MODE,
                                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
                            )
                            // Flash is automatically enabled when necessary.
                            setAutoFlash(previewRequestBuilder!!)

                            // Finally, we start displaying the camera preview.
                            Log.d(TAG, "start display preview")
                            previewRequest = previewRequestBuilder!!.build()
                            captureSession!!.setRepeatingRequest(
                                previewRequest!!,
                                captureCallback, backgroundHandler
                            )
                        } catch (e: CameraAccessException) {
                            Log.e(TAG, e.toString())
                        }
                    }

                    override fun onConfigureFailed(cameraCaptureSession: CameraCaptureSession) {
                        showToast("Failed")
                    }
                },
                null
            )
            cameraSetUpState = 3
        } catch (e: CameraAccessException) {
            Log.e(TAG, e.toString())
        }
    }

    private fun setAutoFlash(requestBuilder: CaptureRequest.Builder) {
        if (flashSupported) {
            requestBuilder.set(
                CaptureRequest.CONTROL_AE_MODE,
                CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH
            )
        }
    }

    private fun selectPreviewSizeResolution(possibleSize: List<Size>, displayRotation: Int): List<Size> {

        val possibleResolution  = mutableListOf<Size>()

        var selectedSize: Size? = null
        var selectedResolution: Size? =  null


        for(size in possibleSize){
            if(size.height <= maxPreviewHeight
                && size.width <= maxPreviewWidth
            ) {
                possibleResolution.add(size)
            }
        }

        //var listOfAspectRatio = possibleResolution.map { it.width.toFloat() / it.height }
        for(reso in possibleResolution){
            val result = if(displayRotation == Surface.ROTATION_0 || displayRotation == Surface.ROTATION_180){
                calNewSizeResolution(0, reso, maxSurViewWidth, maxSurViewHeight, selectedResolution)
            }else{
                calNewSizeResolution(1, reso, maxSurViewWidth, maxSurViewHeight, selectedResolution)
            }

            if(result[0] != null && result[1] != null){
                selectedSize = result[0]
                selectedResolution = result[1]
            }
        }

        if(selectedSize == null){
            for(reso in possibleResolution){
                val result = if(displayRotation == Surface.ROTATION_0 || displayRotation == Surface.ROTATION_180){
                    calNewSizeResolution(1, reso, maxSurViewWidth, maxSurViewHeight, selectedResolution)
                }else{
                    calNewSizeResolution(0, reso, maxSurViewWidth, maxSurViewHeight, selectedResolution)
                }

                if(result[0] != null && result[1] != null){
                    selectedSize = result[0]
                    selectedResolution = result[1]
                }
            }

        }
        return listOf(selectedSize!!, selectedResolution!!)
    }

    /**
     * @param baseOn
     * 0 -> calculate width based on height
     * 1 -> calculate height based on width
     * */
    private fun calNewSizeResolution(baseOn: Int, resolution: Size, maxSurViewWidth: Int, maxSurViewHeight: Int, selectedResolution: Size?): List<Size?>{
        var selectedSize: Size? = null
        var newResolution: Size? = null
        if(baseOn == 0){
            val newWidth = maxSurViewHeight * resolution.width.toFloat() / resolution.height

            if(newWidth < maxSurViewWidth) {
                if (selectedResolution == null || resolution.height * resolution.width > selectedResolution.height * selectedResolution.width){
                    selectedSize = Size(newWidth.toInt(), maxSurViewHeight)
                    newResolution = resolution
                }
            }
        }else{
            val newHeight = maxSurViewWidth * resolution.height.toFloat() / resolution.width
            if(newHeight < maxSurViewHeight) {
                if (selectedResolution == null || resolution.height * resolution.width > selectedResolution.height * selectedResolution.width){
                    selectedSize = Size(maxSurViewWidth, newHeight.toInt())
                    newResolution = resolution
                }
            }

        }
        return listOf(selectedSize, newResolution)
    }

    private fun selectImgReaderResolution(previewResolution: Size, listOfResol: List<Size>): Size{
        val aspectReatio = previewResolution.width.toFloat() / previewResolution.height
        var selectResolution: Size? = null
        for(resol in listOfResol){
            if(resol.width.toFloat() / resol.height == aspectReatio){

                if(selectResolution == null
                    || resol.width * resol.height < selectResolution.width * selectResolution.height){
                    selectResolution = resol
                }
            }
        }
        return selectResolution!!
    }

    fun getImgReaderSize(): Size = imgReaderSize
    fun getSensorOrientation(): Int? = sensorOrientation

    /**
     * Shows an error message dialog.
     */
    private class ErrorDialog : DialogFragment() {

        override fun onCreateDialog(savedInstanceState: Bundle?): Dialog =
            AlertDialog.Builder(activity)
                .setMessage(requireArguments().getString(ARG_MESSAGE))
                .setPositiveButton(android.R.string.ok) { _, _ -> requireActivity().finish() }
                .create()

        companion object {

            @JvmStatic
            private val ARG_MESSAGE = "message"

            @JvmStatic
            fun newInstance(message: String): ErrorDialog = ErrorDialog()
                .apply {
                    arguments = Bundle().apply { putString(ARG_MESSAGE, message) }
                }
        }
    }

}